"""
Created by Xuejian Ma at 6/18/2020.
All rights reserved.
"""
import numpy as np
import matplotlib.pyplot as plt
import pandas as pd
from tqdm.auto import tqdm


def readTXT(filePath):
    """
    Read diffusion data in default txt file to a 2d numpy array.
    :param filePath: txt file generated by Labview diffusion measurement GUI. Default name is "Ch1 retrace.txt" etc.
    :return: 2d array of the diffusion data in the txt file
    """
    f1 = open(filePath)
    data = f1.read()[:-1]
    lines = data.split("\n")
    matrix = []
    for line in lines:
        matrix.append(np.array(line.split("\t")).astype(float))
    return np.asarray(matrix)


def readImRePhase(folderPathList, fileNameIm, fileNameRe, naiveScale):
    """
    Read im and re diffusion files into 1d arrays for phase diagram. Phase diagram is for comparison with simulated
    Im and Re curves by COMSOL.
    :param filePathImList: must have the same length with filePathReList correspondingly.
    :param filePathReList: must have the same length with filePathImList correspondingly.
    :param naiveScale: naiveScale to the raw data. Usually the raw data are in V. To convert them to mV, we need scale=1000.
    :return: 1d array im_all, and 1d array re_all, with only voltage information (no coordinates information)
    """
    im_all = []
    re_all = []
    for folderPath in folderPathList:
        im = readTXT(folderPath + '/' + fileNameIm)
        im_all += list(np.array(im).reshape(1, -1)[0] * naiveScale)
        re = readTXT(folderPath + '/' + fileNameRe)
        re_all += list(np.array(re).reshape(1, -1)[0] * naiveScale)
    return im_all, re_all


def plotImRePhase(filePathImList, filePathReList, saveFigPath):
    """
    Read and Plot im and re diffusion files into 1d arrays for phase diagram. Phase diagram is for comparison with simulated
    Im and Re curves by COMSOL.
    :param filePathImList: must have the same length with filePathReList correspondingly.
    :param filePathReList: must have the same length with filePathImList correspondingly.
    :param saveFigPath: path to save the phase diagram.
    :return: None
    """
    im_all, re_all = readImRePhase(filePathImList, filePathReList)
    plt.plot(np.array(im_all), np.array(re_all), ".")
    plt.savefig(saveFigPath + '/imRePhase.png')
    return None


def readSimulatedImReCSV(filePath, comsolScale):
    '''
    Read the simulated im re curves generated by COMSOL.
    :param filePath: csv file from COMSOL, which contains columns of conductivity, im and re signals.
    :param comsolScale: convert from COMSOL unit to mV.
        comsolScale = 3.5*10 for diffusion. 3.5 is the default calibrated coefficient,
            10 is multiplied to fit the signal amplification of lock-in.
        comsolScale=  3.5/1000*125 for TR-iMIM signals. 3.5 is still default calibrated coefficient, factor of 125/1000 is
            multiplied since 3.5 is for a 1000x DC amplifier, while TR-iMIM uses the amplifier with 125x instead.
    :return: cond_array as x-axis, im_sim, re_sim as y-values
    '''
    df = pd.read_csv(filePath, error_bad_lines=False, skiprows=4)  # Untitled_632
    # diffusion simulation file chosen: Untitled_R28_1degree.csv
    # Tr simulation file chosen: tr2.csv
    cond_array = df.iloc[:, 0]
    # im_sim_raw = df.iloc[:,1]*3.5*10
    # re_sim_raw = df.iloc[:,2]*3.5*10
    im_sim_raw = df.iloc[:, 1] * comsolScale  # * 3.5 / 1000 * 125
    re_sim_raw = df.iloc[:, 2] * comsolScale  # * 3.5 / 1000 * 125
    im_sim = im_sim_raw - np.min(im_sim_raw)
    re_sim = re_sim_raw - np.min(re_sim_raw)
    return cond_array, im_sim, re_sim


def plotSimulatedImReCurves(filePath, saveFigPath, comsolScale):
    '''
    Plot the simulated im re curves generated by COMSOL.
    :param filePath: csv file from COMSOL, which contains columns of conductivity, im and re signals.
    :param saveFigPath: path to save the curves.
    :param comsolScale: see readSimulatedImReCSV().
    :return: None
    '''
    SMALL_SIZE = 8
    MEDIUM_SIZE = 20
    BIGGER_SIZE = 22
    plt.rc('font', size=MEDIUM_SIZE)  # controls default text sizes
    plt.rc('axes', titlesize=BIGGER_SIZE)  # fontsize of the axes title
    plt.rc('axes', labelsize=BIGGER_SIZE)  # fontsize of the x and y labels
    plt.rc('xtick', labelsize=BIGGER_SIZE)  # fontsize of the tick labels
    plt.rc('ytick', labelsize=BIGGER_SIZE)  # fontsize of the tick labels
    plt.rc('legend', fontsize=MEDIUM_SIZE)  # legend fontsize
    plt.rc('figure', titlesize=BIGGER_SIZE)  # fontsize of the figure title
    plt.rc('axes', linewidth=2)
    plt.rc('xtick.major', size=5, width=3)
    plt.rc('ytick.major', size=5, width=3)
    cond_array, im_sim, re_sim = readSimulatedImReCSV(filePath, comsolScale)
    plt.figure()
    plt.xscale('log')
    # plt.xlim(1e-7,7e6)
    # plt.plot(cond_array,im_sim,'.')
    # plt.plot(cond_array,re_sim,'.')
    plt.plot(cond_array, im_sim, color='red', linewidth=6, label="iMIM-Im")
    plt.plot(cond_array, re_sim, color='green', linewidth=6, label="iMIM-Re")
    plt.xlabel("Local Ïƒ (nS)")
    plt.ylabel("Simulated Signals (mV)")
    plt.legend()
    plt.tight_layout()
    plt.savefig(saveFigPath + "/simulatedImReCurves.png")
    return None


def plotSimulatedImReCurves_Linear(filePath, saveFigPath, comsolScale, maxPos=107, maxTick=12, tickStep=2):
    '''
    Plot the simulated im re curves generated by COMSOL in the LINEAR SCOPE.
    :param filePath: csv file from COMSOL, which contains columns of conductivity, im and re signals.
    :param saveFigPath: path to save the curves.
    :param comsolScale: see readSimulatedImReCSV().
    :param maxPos: see below for details.
    :param maxTick: see below for details.
    :param tickStep: see below for details.
    :return: None
    '''
    SMALL_SIZE = 8
    MEDIUM_SIZE = 25
    BIGGER_SIZE = 35

    plt.rc('font', size=MEDIUM_SIZE)  # controls default text sizes
    plt.rc('axes', titlesize=BIGGER_SIZE)  # fontsize of the axes title
    plt.rc('axes', labelsize=BIGGER_SIZE)  # fontsize of the x and y labels
    plt.rc('xtick', labelsize=BIGGER_SIZE)  # fontsize of the tick labels
    plt.rc('ytick', labelsize=BIGGER_SIZE)  # fontsize of the tick labels
    plt.rc('legend', fontsize=MEDIUM_SIZE)  # legend fontsize
    plt.rc('figure', titlesize=BIGGER_SIZE)  # fontsize of the figure title
    plt.rc('axes', linewidth=4)
    plt.rc('xtick.major', size=5, width=3)
    plt.rc('ytick.major', size=5, width=3)
    cond_array, im_sim, re_sim = readSimulatedImReCSV(filePath, comsolScale)
    rc = list(range(0, maxPos))
    plt.figure()
    plt.plot(cond_array[rc], im_sim[rc], color='red', linewidth=10, label="iMIM-Im")
    plt.plot(cond_array[rc], re_sim[rc], color='green', linewidth=10, label="iMIM-Re")
    plt.xticks(list(range(0, maxTick, tickStep)))
    plt.savefig(saveFigPath + "/simulatedImReCurves_Linear.png")
    return None


def plotPhaseAndSimulatedCurves(im_all, re_all, im_sim, re_sim, saveFigPath):
    """
    Plot both phase diagram and simulated im re curves in one figure, in order to see the quality of simulation.
    :param im_all: from readImRePhase()
    :param re_all: from readImRePhase()
    :param im_sim: from readSimulatedImReCSV()
    :param re_sim: from readSimulatedImReCSV()
    :param saveFigPath: path to save the figure.
    :return: None
    """
    plt.figure()
    plt.plot(np.array(im_all), np.array(re_all), ".")
    plt.plot(im_sim, re_sim)
    plt.savefig(saveFigPath + "/phaseAndSimulatedCurves.png")
    return None


def distance(pt1, pt2):
    return np.sqrt((pt1[0] - pt2[0]) ** 2 + (pt1[1] - pt2[1]) ** 2)


def nearestIndex(pt, array_with_conductivity):
    # pt: (x,y)
    # array_with_conductivity: [((x,y),conductivity),...]
    distance_list = []
    for item in array_with_conductivity:
        distance_list.append(distance(pt, item[0]))
    return distance_list.index(np.min(distance_list))


def readImRe(folderPath, fileNameIm, fileNameRe, naiveScale):
    filePathIm = folderPath + '/' + fileNameIm
    filePathRe = folderPath + '/' + fileNameRe
    im_img_array = []
    with open(filePathIm) as f:
        data = f.read()[:-1]
        lines = data.split("\n")
        for line in lines:
            im_img_array.append(np.array(line.split("\t")).astype(float) * naiveScale)
    re_img_array = []
    with open(filePathRe) as f:
        data = f.read()[:-1]
        lines = data.split("\n")
        for line in lines:
            re_img_array.append(np.array(line.split("\t")).astype(float) * naiveScale)
    return np.asarray(im_img_array), np.asarray(re_img_array)


def mim2Conductivity(folderPath, fileNameIm, fileNameRe, csvFilePath, comsolScale, naiveScale):
    im_img_array, re_img_array = readImRe(folderPath, fileNameIm, fileNameRe, naiveScale)
    cond_array, im_sim, re_sim = readSimulatedImReCSV(csvFilePath, comsolScale)
    array_with_conductivity = []
    for im, re, conductivity in zip(im_sim, re_sim, cond_array):
        array_with_conductivity.append(((im, re), conductivity))

    conductivity_img_array = []
    for i in tqdm(range(len(im_img_array))):
        #         print(i/len(im_img_array))
        img_line = []
        for j in range(len(re_img_array)):
            pt = (im_img_array[i][j], re_img_array[i][j])
            conductivity_index = nearestIndex(pt, array_with_conductivity)
            # print(conductivity_index)
            img_line.append(array_with_conductivity[conductivity_index][1])
        conductivity_img_array.append(img_line)

    np.savetxt(folderPath + "/conductivity.txt", conductivity_img_array)
    return None


def readConductivity(folderPath):
    with open(folderPath + "/conductivity.txt") as f:
        data = f.read()[:-1]
        lines = data.split("\n")
        conductivity_f = []
        #     print(lines)
        for line in lines:
            conductivity_f.append(np.array(line.split(" ")).astype(float))  # use space as splitter instead of /t
    return conductivity_f

def undistort_1D(appear,coeff1,coeff2):
    # appear = coeff1*real^2 + coeff2*real
    # coeff1*real**2 + coeff2*real - appear = 0
    return (-coeff2+np.sqrt(coeff2**2-4*coeff1*-appear))/(2*coeff1)

def calibrate_xlist(xList,coeff1 = 0.06944444444444448, coeff2 = 2.4833333333333334, extra_scale_x = 1.0):
    new_xList = []
    for x in xList:
        new_xList.append(-undistort_1D(np.max(xList)-x,coeff1,coeff2)*extra_scale_x)
    return new_xList

# def calibrate_ylist(yList,coeff1 = 0.0152777777777777793, coeff2 = 5.250000000000001, extra_scale_y = 1.0):
def calibrate_ylist(yList,coeff1 = 0.04583333333333334, coeff2 = 3.5000000000000004, extra_scale_y = 1.0):
    new_yList = []
    for y in yList:
        new_yList.append(undistort_1D(y,coeff1,coeff2)*extra_scale_y)
    return new_yList